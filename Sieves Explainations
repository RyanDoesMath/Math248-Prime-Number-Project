The Sieve of Eratosthenes is a simple and ancient algorithm that is used to make prime numbers up to a given limit. It is widely considered to be one of the most efficient ways to find small prime numbers. It begins by defining an upper limit n. Then starting from 2 the algorithm iteratively marks the multiples of primes as composite. Then multiples of 3 are marked as composite and so on until p <= sqrt(n) where p is a prime number. So consider n = 120. We begin with the smallest prime number 2. Then mark all multiples of p < n as composite in the list we are aggregating our primes in as 0. Note that you do not mark p as composite. Set the value of p to the next smallest prime. The next prime will be added as the next non-zero number into the list of prime numbers. Repeat until p <= sqrt(n). Now all non-zero numbers in the list are primes and the numbers that are 0 in the list represent the composite numbers.

Generate all primes less than 11:
List all integers from 2 to 10. {2,3,4,5,6,7,8,9,10}
Let p = 2.
2^2 <= 10 so we can continue.
All multiples of two are set as composite by making their values 0. {2,3,0,5,0,7,0,9,0}
Let p = 3.
3^2 <= 10 so we can continue.
All multiples of three are set as composite by making their values 0. {2,3,0,5,0,7,0,0,0}
Let p = 5.
Since 5^2 !<=10 we cannot continue.
The list of primes are {2,3,0,5,0,7,0,0,0} hence our primes less than 11 are 2,3,5,7.

The Sieve of Sundaram was an algorithm that sieves primes that was discovered by Sundaram in 1934. Like the above Sieve of Eratosthenes it finds all primes numbers up to a given integer. The sieve can be written as ‘i + j + 2ij < m’. In the algorithm, 2k+1 is prime where k is expressed as ‘i + j + 2ij’. This can be rewritten as (2i + 1)(2j + 1). Both numbers 2i + 1 & 2j + 1 are by definition since any multiple of 2 is even and if you add one it will be odd. Any number that is given by the product of two odd numbers are composite. Of the odd numbers the ones that cannot be written as the product of odd numbers are prime. So in a nested for loop we can loop through all the possible odd composite numbers and remove them from our list so that we are only left with odd prime numbers. Since there is only one even prime number this works to our benefit as we can just add 2 to the list and we have our list of prime numbers up to our given integer.

Trial division is a brute force method to finding the divisor of an integer by using a set of integers and seeing if they divide. Repeated use of the trial division will complete the prime factorization of a number called the direct search factorization. This method take a given integer n and divides it with any number smaller than n to see if n is divisible. In python we begin with an empty list. We begin with the first possible factor 2. Then we have a while loop that checks if n still has remaining factors. If the remainder of n divided by our factor is 0  then it divides n. Then we add the factor to our list. Then we divide the factor out of n. If f is not a factor we add one to to the factor and try again. We can then return the prime factors of our number. From here we can decrement n and continue trial division for all n until n = 2. Then we can aggregate the lists and convert the list into a set to get all prime factors under our given initial n number. Trial division is by far the worst way to find primes due to the sheer amount or computing needed to complete it since it is checking every possible prime over every possible number under n and aggregating multiple lists bounded by the initial number n.
